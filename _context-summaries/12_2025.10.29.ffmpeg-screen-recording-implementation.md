# Context Summary: FFmpeg-Based Screen Recording Implementation
**Date:** 2025.10.29  
**Complexity:** Complex

## Overview
Implemented screen and webcam recording functionality using FFmpeg's avfoundation device on macOS, as an alternative to MediaDevices API which is not available in Tauri webview.

## Key Files
- `src-tauri/src/recording.rs` - Recording state management and Tauri commands
- `src-tauri/src/ffmpeg.rs` - FFmpeg screen/webcam recording methods
- `src/services/recordingService.ts` - Frontend service wrapper for Tauri commands
- `src/components/Recording/RecordingPanel.tsx` - Recording UI component
- `src/store/appStore.ts` - Added recording state management

## Important Details

### Discovery: MediaDevices API Not Available
**Problem:** Tauri webview on macOS does not expose `navigator.mediaDevices` API, even in secure contexts (localhost). This is a known limitation where the WebView doesn't expose MediaDevices by default.

**Error Message:**
```
MediaDevices API is not available (running in secure context).
Location: http://localhost:1420/
```

**Root Cause:** Tauri's WKWebView doesn't expose MediaDevices API, requiring native implementation.

### Solution: FFmpeg avfoundation Recording
Since MediaDevices isn't available, we implemented native FFmpeg-based recording using macOS's avfoundation device.

**Key Implementation Details:**

1. **FFmpeg avfoundation Input Format:**
   ```rust
   // Correct format: "-i" "<video_device_index>:<audio_device_index>"
   // For screen: Device index 3 is typically "Capture screen 0"
   // Format: "3:1" for screen + microphone, "3:none" for screen only
   args.push("-i");
   args.push("3:1".to_string()); // Screen 0 + audio device 1
   ```

2. **Device List Discovery:**
   Run `ffmpeg -f avfoundation -list_devices true -i ""` to see available devices:
   - Video devices: [0] FaceTime HD Camera, [1] iPhone Camera, [3] Capture screen 0, [4] Capture screen 1
   - Audio devices: [0] BlackHole, [1] MacBook Pro Microphone
   - Screen devices are typically at indices 3+ (after cameras)

3. **Critical FFmpeg Command Structure:**
   ```rust
   // Screen recording command structure
   vec![
       "-f", "avfoundation",
       "-capture_cursor", "1",      // Capture mouse cursor
       "-capture_mouse_clicks", "1", // Capture mouse clicks
       "-i", "3:1",                  // Screen 0 + microphone
       "-c:v", "libx264",            // H.264 codec
       "-preset", "ultrafast",       // Low latency
       "-crf", "23",                 // Quality
       "-r", "30",                   // Frame rate
       "-y",                         // Overwrite output
       output_path
   ]
   ```

4. **Graceful Process Shutdown:**
   **Critical Issue:** Abruptly killing FFmpeg can result in incomplete files with "No video stream found" errors when trying to read metadata.
   
   **Solution:** Implement graceful shutdown sequence:
   ```rust
   // 1. Send 'q' to stdin (if available) for graceful quit
   if let Some(stdin) = process.stdin.as_mut() {
       stdin.write_all(b"q")?;
   }
   
   // 2. Give FFmpeg time to finalize (500ms)
   std::thread::sleep(Duration::from_millis(500));
   
   // 3. If still running, send SIGTERM
   if process.try_wait()?.is_none() {
       libc::kill(pid, libc::SIGTERM);
   }
   
   // 4. Wait for completion
   process.wait()?;
   ```

   **Note:** FFmpeg must be spawned with stdin captured:
   ```rust
   cmd.stdin(std::process::Stdio::piped());
   ```

5. **Recording State Management:**
   - Use `Arc<Mutex<RecordingState>>` for thread-safe state sharing
   - Store `Child` process handle to enable graceful shutdown
   - Track output path for file import after recording

### FFmpeg Command Patterns

**Screen Recording:**
- Video device: Index 3 ("Capture screen 0")
- Audio device: Index 1 (MacBook microphone) or "none"
- Input format: `"3:1"` or `"3:none"`

**Webcam Recording:**
- Video device: Index 0+ (cameras listed first)
- Audio device: Index 1 (microphone) or "none"
- Input format: `"<camera_index>:1"` or `"<camera_index>:none"`

**Both cannot be recorded simultaneously** without compositing (complex, deferred for MVP).

### Process Flow

1. **Start Recording:**
   - User selects source (screen/webcam), resolution, fps, audio
   - Frontend opens save dialog to choose output path
   - Frontend calls `start_screen_recording` or `start_webcam_recording` Tauri command
   - Rust spawns FFmpeg process with avfoundation input
   - Process handle stored in shared state

2. **During Recording:**
   - Frontend shows timer (updates every 100ms)
   - FFmpeg writes directly to output file
   - No live preview available (FFmpeg doesn't provide streams)

3. **Stop Recording:**
   - User clicks Stop
   - Frontend calls `stop_recording` Tauri command
   - Rust gracefully stops FFmpeg (send 'q', wait, SIGTERM if needed)
   - Returns output file path
   - Frontend imports file to media library using `videoService.createMediaFileFromPath()`

### Error Handling

**Common Issues:**
1. **"No video stream found"** - Usually means file wasn't finalized properly (use graceful shutdown)
2. **Permission denied** - macOS requires screen recording permission in System Preferences
3. **Device not found** - Screen index might be different (check with `-list_devices`)

**Error Propagation:**
- FFmpeg errors captured from stderr
- Wrapped in user-friendly messages via error handling utilities
- Displayed via toast notifications

## Testing Notes

**To test recording:**
1. Grant screen recording permission: System Preferences → Security & Privacy → Screen Recording
2. Grant camera permission if using webcam
3. Click Record → Choose output location → Start
4. Wait a few seconds → Stop
5. Verify file is created and importable

**Troubleshooting:**
- If "No video stream found": Check if FFmpeg process was gracefully stopped
- If permission denied: Check System Preferences permissions
- If device not found: Verify device index with `ffmpeg -f avfoundation -list_devices true -i ""`

## Next Steps

**Known Limitations:**
- No live preview (FFmpeg doesn't expose streams)
- No pause/resume (stop and restart instead)
- "Both" mode not implemented (would require video compositing)

**Future Enhancements:**
- List available cameras dynamically
- Add screen selection UI (multiple monitors)
- Implement compositing for screen + webcam simultaneous recording
- Add recording quality presets

## Code Pattern

```rust
// Key pattern: Graceful FFmpeg shutdown
let mut cmd = Command::new(&ffmpeg_path);
cmd.stdin(std::process::Stdio::piped()); // Must capture stdin!
// ... build args ...
let mut child = cmd.spawn()?;

// To stop gracefully:
if let Some(stdin) = child.stdin.as_mut() {
    stdin.write_all(b"q")?; // Send quit command
}
std::thread::sleep(Duration::from_millis(500)); // Allow finalization
if child.try_wait()?.is_none() {
    child.kill()?; // Force if still running
}
child.wait()?; // Wait for completion
```

