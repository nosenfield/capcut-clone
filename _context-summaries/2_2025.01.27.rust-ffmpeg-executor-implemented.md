# Rust FFmpeg Executor Implementation

**Date**: 2025-01-27  
**Session**: Phase 2 - Backend Integration  
**Status**: ✅ Complete

## Task Summary

**Task 2.2**: Implement Rust FFmpeg executor module

Created the FFmpeg executor that handles media operations including metadata extraction, thumbnail generation, and video export.

## What Was Built

### File Created

**`src-tauri/src/ffmpeg.rs`** (267 lines)

Implements the FFmpegExecutor struct with methods for:
- Media metadata extraction via FFprobe
- Thumbnail generation at specific timestamps
- Video export with filter complex construction
- JSON parsing for FFprobe output
- FPS parsing (handles fractional rates like "30000/1001")

### Struct Definitions

**MediaMetadata** - FFprobe output structure:
```rust
pub struct MediaMetadata {
    pub duration: f64,
    pub width: u32,
    pub height: u32,
    pub fps: f64,
    pub codec: String,
    pub bitrate: u64,
}
```

**ClipInfo** - Clip information for export:
```rust
pub struct ClipInfo {
    pub file_path: String,
    pub start_time: f64,
    pub duration: f64,
    pub trim_start: f64,
    pub trim_end: f64,
}
```

### Key Methods Implemented

**1. `FFmpegExecutor::new()`**
- Resolves binary paths from manifest directory (dev mode)
- Verifies binaries exist
- Returns Result for error handling

**2. `get_metadata(&self, file_path)`**
- Runs FFprobe with JSON output
- Parses stream and format information
- Extracts duration, resolution, FPS, codec, bitrate
- Handles video stream detection

**3. `parse_metadata(&self, json)`**
- Private helper method
- Parses FFprobe JSON output
- Extracts video stream metadata
- Converts string numbers to appropriate types

**4. `parse_fps(&self, fps_str)`**
- Handles fractional FPS (e.g., "30000/1001" = 29.97 fps)
- Also handles decimal FPS (e.g., "30")
- Returns Result with descriptive errors

**5. `generate_thumbnail(&self, file_path, timestamp, output_path)`**
- Extracts frame at specific timestamp
- Uses FFmpeg with `-vframes 1`
- High quality setting (`-q:v 2`)
- Outputs to specified path

**6. `export_video(&self, clips, output_path, resolution, fps)`**
- Builds filter complex for concatenation
- Trims and scales each clip
- Concatenates all clips sequentially
- Exports with H.264 codec (CRF 23, medium preset)

**7. `build_filter_complex(&self, clips, resolution)`**
- Generates FFmpeg filter complex string
- Handles resolution scaling (720p, 1080p, source)
- Creates trim filters for each clip
- Builds concat filter for final output

## Technical Decisions

### Binary Path Resolution

**Challenge**: FFmpeg binaries need to be found both in dev and production builds.

**Solution**: Use `CARGO_MANIFEST_DIR` environment variable for dev mode to locate binaries in project directory. Production builds will use Tauri resource directory (to be implemented in Task 2.3).

```rust
let manifest_dir = std::env::var("CARGO_MANIFEST_DIR")
    .map_err(|e| format!("Failed to get manifest dir: {}", e))?;
let manifest_path = PathBuf::from(manifest_dir);
let binaries_dir = manifest_path.join("binaries");
```

### Error Handling

All methods return `Result<T, String>` for consistent error handling:
- FFmpeg/FFprobe execution errors include stderr output
- JSON parsing errors are descriptive
- File path verification errors are clear

### FPS Parsing

**Challenge**: FFmpeg can report FPS in multiple formats (decimal or fractional).

**Solution**: Check for `/` character to detect fractional format:
- "30000/1001" → `30000.0 / 1001.0` = 29.97 fps
- "30" → `30.0` fps directly

### Export Strategy

Uses filter complex for multi-clip exports:
1. Trim each input clip with `trim=start=X:duration=Y`
2. Scale to target resolution (if not "source")
3. Set PTS to start at zero with `setpts=PTS-STARTPTS`
4. Concatenate all processed clips with `concat` filter
5. Export with H.264 codec and reasonable defaults

## Files Modified

- `src-tauri/src/lib.rs` - Added `mod ffmpeg;`

## Testing

### Compilation
```bash
cd src-tauri
cargo build
# ✅ Exit code 0 - compiles successfully
# Expected warnings: unused types (will be used in Task 2.3)
```

### Expected Warnings
- `MediaMetadata` never constructed
- `ClipInfo` never constructed
- `FFmpegExecutor` never constructed
- Multiple associated items never used

These warnings are expected since the Tauri commands (Task 2.3) haven't been implemented yet to call these methods.

## Acceptance Criteria Met

From `task-list-mvp.md` Task 2.2:

- ✅ `FFmpegExecutor` compiles without errors
- ✅ Binary paths resolve correctly (uses manifest directory)
- ✅ FFprobe JSON parsing implemented
- ✅ FPS parsing handles fractional rates (e.g., "30000/1001")
- ✅ Error messages include stderr output
- ✅ All methods return `Result` for error handling

## Integration Points

### Ready for Task 2.3

The FFmpeg executor will be used by Tauri commands in `commands.rs`:
- `get_media_metadata` → `FFmpegExecutor::get_metadata()`
- `generate_thumbnail` → `FFmpegExecutor::generate_thumbnail()`
- `export_video` → `FFmpegExecutor::export_video()`

### Module Dependencies

- **Module 5 (FFmpeg Integration)**: This file implements Module 5
- **Module 4 (Tauri Commands)**: Next task will create commands that use this
- **Module 6 (Frontend Service)**: Frontend will call commands that use this

## Code Quality

### Rust Best Practices
- ✅ Struct fields properly typed
- ✅ Error handling with Result<T, String>
- ✅ Descriptive error messages
- ✅ Private helper methods where appropriate
- ✅ Documentation comments for public methods

### Performance Considerations
- Serial execution (no async wrapper yet)
- Filter complex construction optimized for FFmpeg
- Error messages include full context

## Known Limitations

1. **Production Path**: Currently uses dev manifest path. Production builds will need resource directory resolution (to be handled in commands).
2. **Synchronous**: All operations are blocking. Async wrapper would be better for UI responsiveness.
3. **No Progress**: Export operations don't report progress percentage yet (future enhancement).

## Known Issues & Solutions

### Tauri Build Cache Issues

**Problem**: When adding or modifying resources in `tauri.conf.json`, cargo build may fail with "Permission denied" errors even though binaries have correct permissions.

**Root Cause**: Stale build artifacts from previous configurations can cause conflicts when Tauri processes new resource entries.

**Symptoms**:
- `Permission denied (os error 13)` during build
- Binaries exist and have correct permissions (555)
- Error occurs in build-script phase

**Solution**:
```bash
cd src-tauri
cargo clean
cargo build
```

**When to Use**: 
- After modifying `tauri.conf.json` resources
- After changing FFmpeg binaries
- After updating capabilities/permissions
- Any time cargo build shows unexpected permission errors

**Prevention**: Consider running `cargo clean && cargo build` proactively after configuration changes to avoid time-consuming troubleshooting.

## Next Steps

**Task 2.3**: Create Tauri Commands
- Create `src-tauri/src/commands.rs`
- Implement `get_media_metadata` command
- Implement `generate_thumbnail` command  
- Implement `export_video` command
- Register commands in lib.rs invoke_handler

## Related Files

- `_docs/architecture.md` - Module 5 specification
- `_docs/task-list-mvp.md` - Task 2.2 details
- `src-tauri/Cargo.toml` - Dependencies (serde, serde_json already present)
- `src-tauri/binaries/` - FFmpeg binaries location

## Notes

- FFmpeg executor is the core backend for all media operations
- All FFmpeg operations are synchronous (Rust async wrapper can be added later)
- Error messages include stderr for debugging
- Filter complex construction is flexible for multiple clip concatenation
- Ready to be integrated with Tauri IPC commands

