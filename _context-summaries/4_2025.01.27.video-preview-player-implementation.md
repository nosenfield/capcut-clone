# Context Summary: Task 5.1 - Video Preview Player Implementation
**Date:** 2025-01-27  
**Complexity:** Complex  
**Phase:** Phase 5.1 Complete - Video Preview

## Overview

Implemented HTML5 video preview player component with blob URL loading, replacing thumbnail placeholder. Video playback synchronized with timeline playhead using requestAnimationFrame. Playback controlled by Timeline component.

## Key Files Modified

- `src/components/Preview/PreviewPlayer.tsx` - Complete rewrite with HTML5 video element
- `package.json` - Added @tauri-apps/plugin-fs dependency  
- `package-lock.json` - Updated dependencies
- `src-tauri/binaries/ffmpeg` - Fixed permissions (chmod 755)
- `src-tauri/binaries/ffprobe` - Fixed permissions (chmod 755)

## Important Discoveries

### Issue 1: FFmpeg Binary Permissions
**Problem:** Build failing with "Permission denied (os error 13)"  
**Cause:** Binaries were executable (-xr-xr-x) but build script couldn't read them  
**Solution:**
```bash
chmod 755 src-tauri/binaries/ffmpeg src-tauri/binaries/ffprobe
# Result: -rwxr-xr-x (owner read+write+execute, group+others read+execute)
```

### Issue 2: Tauri File Protocol for User-Selected Files
**Problem:** `convertFileSrc()` didn't work with files outside app scope (user-selected videos)  
**Solution:** Use Tauri FS plugin to read file and create blob URL:
```typescript
import { readFile } from '@tauri-apps/plugin-fs';

const data = await readFile(currentMedia.path);
const blob = new Blob([data], { type: 'video/mp4' });
const blobUrl = URL.createObjectURL(blob);
```

**Why this works:** Blob URLs are accessible in browser context without protocol issues. Files selected via dialog need to be accessed through Tauri API, not direct file paths.

### Issue 3: Playback Control Architecture
**Initial approach:** Separate play/pause button in PreviewPlayer  
**Final approach:** Remove PreviewPlayer controls, use Timeline component controls  
**Reason:** Single source of truth for play state, cleaner UI separation

## Implementation Details

### Blob URL Loading
```typescript
React.useEffect(() => {
  if (!currentMedia?.path) return;
  
  let blobUrl: string | null = null;
  
  const loadVideo = async () => {
    try {
      const data = await readFile(currentMedia.path);
      const blob = new Blob([data], { type: 'video/mp4' });
      blobUrl = URL.createObjectURL(blob);
      setVideoSrc(blobUrl);
    } catch (error) {
      // Fallback to convertFileSrc
      const src = convertFile Spectral(currentMedia.path);
      setVideoSrc(src);
    }
  };
  
  loadVideo();
  
  // Cleanup on unmount
  return () => {
    if (blobUrl) URL.revokeObjectURL(blobUrl);
  };
}, [currentMedia?.path]);
```

**Key Points:**
- Create blob URL when media changes
- Always revoke old blob URL to prevent memory leaks
- Fallback to convertFileSrc for robustness

### Video Time Calculation
```typescript
const videoTime = useMemo(() => {
  if (!currentClip || !currentMedia) return 0;
  
  // Offset into clip from playhead position
  const offsetIntoClip = playheadPosition - currentClip.startTime;
  
  // Apply trimStart and clamp to valid range
  const time = currentClip.trimStart + offsetIntoClip;
  const maxTime = currentMedia.duration - currentClip.trimEnd;
  
  return Math.max(0, Math.min(time, maxTime));
}, [currentClip, currentMedia, playheadPosition]);
```

**Why:** Video element's currentTime must account for:
1. Where playhead is on timeline
2. Where clip starts on timeline
3. Clip's trimStart (offset from source start)
4. Clip's trimEnd (duration reduction)

### Playback Synchronization
```typescript
React.useEffect(() => {
  if (!isPlaying) {
    // Pause video
    if (videoRef.current && !videoRef.current.paused) {
      videoRef.current.pause();
    }
    return;
  }
  
  let animationFrameId: number;
  
  const updatePlayhead = () => {
    if (!videoRef.current || !currentClip) return;
    
    // Calculate timeline position from video time
    const actualVideoTime = videoRef.current.currentTime;
    const timelineTime = currentClip.startTime + (actualVideoTime - currentClip.trimStart);
    
    // Update playhead
    setPlayheadPosition(timelineTime);
    
    // Check end
    if (timelineTime >= currentClip.startTime + currentClip.duration || timelineTime >= duration) {
      setIsPlaying(false);
      if (videoRef.current) videoRef.current.pause();
    } else {
      animationFrameId = requestAnimationFrame(updatePlayhead);
    }
  };
  
  // Start playing
  if (videoRef.current && videoRef.current.paused) {
    videoRef.current.play().catch(err => {
      console.error('Error playing video:', err);
      setIsPlaying(false);
    });
  }
  
  animationFrameId = requestAnimationFrame(updatePlayhead);
  
  return () => {
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
  };
}, [isPlaying, currentClip, duration, setPlayheadPosition, setIsPlaying]);
```

**Flow:**
1. When `isPlaying` becomes true, start video.play()
2. requestAnimationFrame loop updates playhead from video.currentTime
3. Convert video time to timeline time considering clip position + trim
4. Update store with new playhead position
5. Cleanup RAF on pause/end/unmount

## Video Element Configuration
```typescript
<video
  ref={videoRef}
  src={videoSrc}
  className="w-auto h-auto max-w-full max-h-full"
  style={{ maxWidth: '100%', maxHeight: '100%', objectFit: 'contain' }}
  playsInline
  muted={false}
  controls={false}
/>
```

**Key attributes:**
- `playsInline`: Required for iOS, helps with desktop too
- `controls={false}`: Custom controls via Timeline
- `muted={false}`: Play with audio
- `objectFit: 'contain'`: Maintain aspect ratio, fit in container

## Tauri FS Plugin Setup

### Frontend
```bash
npm install @tauri-apps/plugin-fs
```

```typescript
import { readFile } from '@tauri-apps/plugin-fs';
```

### Backend (Already configured)
```rust
// src-tauri/src/lib.rs
.plugin(tauri_plugin_fs::init())
```

## Code Patterns

### Blob URL Lifecycle
```typescript
// Create
const blobUrl = URL.createObjectURL(blob);

// Use
setVideoSrc(blobUrl);

// Cleanup (critical!)
URL.revokeObjectURL(blobUrl);
```

### RAF Playback Loop
```typescript
let animationFrameId: number;

const update = () => {
  // Update state
  updatePlayhead();
  
  // Continue loop
  animationFrameId = requestAnimationFrame(update);
};

animationFrameId = requestAnimationFrame(update);

// Cleanup
return () => cancelAnimationFrame(animationFrameId);
```

### Error Handling for video.play()
```typescript
videoRef.current.play()
  .then(() => console.log('Playing'))
  .catch(err => {
    console.error('Playback failed:', err);
    setIsPlaying(false);
  });
```

## Known Limitations

1. **File Loading:** Reads entire video into memory (blob limit)
   - Works for <100MB files
   - Future: Stream chunks or use media source extensions

2. **No Scrubbing:** Can't drag progress bar
   - Future: Add seek functionality to Timeline playhead

3. **Single Clip Playback:** Plays current clip only
   - Future: Seamless multi-clip playback

4. **No Audio Visualization:** Audio plays but no waveform
   - Future: Canvas-based waveform rendering

## Testing Notes

### Debug Event Handlers
Initially added comprehensive event logging:
```typescript
onLoadStart={() => console.log('Video load started')}
onLoadedMetadata={() => console.log('Video metadata loaded')}
onLoadedData={() => console.log('Video data loaded')}
onCanPlay={() => console.log('Video can play')}
onPlay={() => console.log('Video onPlay event fired')}
onPlaying={() => console.log('Video onPlaying event fired')}
onPause={() => console.log('Video onPause event fired')}
onError={(e) => console.error('Video error:', e)}
```

### Console Output During Development
```
Reading video file: /Users/.../video.mp4
Created blob URL: blob:http://localhost:1420/abc123...
Video load started
Video metadata loaded
Video data loaded
Video can play
Video onPlay event fired
Video onPlaying event fired
```

## Git Commit

```
[Phase 5.1] Implement video preview player with blob URL loading
- Replaced thumbnail with HTML5 video element
- Implemented blob URL loading using Tauri FS plugin
- Added playhead synchronization with requestAnimationFrame
- Video playback controlled by Timeline component
- Fixed FFmpeg binary permissions
```

## Next Steps

**Phase 6: Basic Editing**
- Task 6.1: Implement clip selection
- Task 6.2: Implement basic trim controls

## Important Reminders

### Blob URL Memory Management
**ALWAYS revoke blob URLs on cleanup** to prevent memory leaks:
```typescript
return () => {
  if (blobUrl) URL.revokeObjectURL(blobUrl);
};
```

### Tauri File Access
- User-selected files: Use FS plugin â†’ blob URLs
- App assets: Use convertFileSrc
- Never use file:// protocol directly

### RAF Loop Best Practices
- Always store RAF ID for cleanup
- Cleanup on unmount/state change
- Handle errors gracefully
- Check element exists before accessing

## Files to Reference

- `src/components/Preview/PreviewPlayer.tsx` - Video player implementation
- `src/components/Timeline/Timeline.tsx` - Playback controls
- `src/store/timelineStore.ts` - Play state management
- `_docs/architecture.md` - Module 9 (Video Preview Player)
- `_docs/task-list-mvp.md` - Task 5.1-5.2

